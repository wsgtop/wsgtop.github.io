<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="来自腾讯社区 1. session，cookie和token究竟是什么1.1. http是一个无状态协议什么是无状态呢？就是说这一次请求和上一次请求是没有任何关系的，互不认识的，没有关联的。这种无状态的的好处是快速。 1.2. cookie和session由于http的无状态性，为了使某个域名下的所有网页能够共享某些数据，session和cookie出现了。客户端访问服务器的流程如下&amp;nbsp;&amp;">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/1.%20%E6%88%91%E7%9A%84%E6%96%87%E4%BB%B6/session%EF%BC%8Ccookie%E5%92%8Ctoken%E7%9A%84%E5%8C%BA%E5%88%AB.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="来自腾讯社区 1. session，cookie和token究竟是什么1.1. http是一个无状态协议什么是无状态呢？就是说这一次请求和上一次请求是没有任何关系的，互不认识的，没有关联的。这种无状态的的好处是快速。 1.2. cookie和session由于http的无状态性，为了使某个域名下的所有网页能够共享某些数据，session和cookie出现了。客户端访问服务器的流程如下&amp;nbsp;&amp;">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/1.%20%E6%88%91%E7%9A%84%E6%96%87%E4%BB%B6/_v_images/20210913151558463_21161.png">
<meta property="article:published_time" content="2021-09-22T11:10:42.652Z">
<meta property="article:modified_time" content="2021-09-22T11:10:42.652Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/1.%20%E6%88%91%E7%9A%84%E6%96%87%E4%BB%B6/_v_images/20210913151558463_21161.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="page-" class="h-entry article article-type-page" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/1.%20%E6%88%91%E7%9A%84%E6%96%87%E4%BB%B6/session%EF%BC%8Ccookie%E5%92%8Ctoken%E7%9A%84%E5%8C%BA%E5%88%AB.html" class="article-date">
  <time class="dt-published" datetime="2021-09-22T11:10:42.652Z" itemprop="datePublished">2021-09-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1683290">来自腾讯社区</a></p>
<h1 id="1-session，cookie和token究竟是什么"><a href="#1-session，cookie和token究竟是什么" class="headerlink" title="1. session，cookie和token究竟是什么"></a>1. session，cookie和token究竟是什么</h1><h2 id="1-1-http是一个无状态协议"><a href="#1-1-http是一个无状态协议" class="headerlink" title="1.1. http是一个无状态协议"></a>1.1. http是一个无状态协议</h2><p>什么是无状态呢？就是说这一次请求和上一次请求是没有任何关系的，互不认识的，没有关联的。这种无状态的的好处是快速。</p>
<h2 id="1-2-cookie和session"><a href="#1-2-cookie和session" class="headerlink" title="1.2. cookie和session"></a>1.2. cookie和session</h2><p>由于http的无状态性，为了使某个域名下的所有网页能够共享某些数据，session和cookie出现了。客户端访问服务器的流程如下</br><br><img src="_v_images/20210913151558463_21161.png" alt="tb8nwm0013"></br><br>&nbsp;&nbsp;首先，客户端会发送一个http请求到服务器端。服务器端接受客户端请求后，建立一个session，并发送一个http响应到客户端，</br><br>这个响应头，其中就包含Set-Cookie头部。该头部包含了sessionId。Set-Cookie格式如下，具体请看Cookie详解</br><br><code>Set-Cookie: value[; expires=date][; domain=domain][; path=path][; secure]</code></br><br>在客户端发起的第二次请求，假如服务器给了set-Cookie，浏览器会自动在请求头中添加cookie</br><br>服务器接收请求，分解cookie，验证信息，核对成功后返回response给客户端</br></p>
<h3 id="1-2-1-注意"><a href="#1-2-1-注意" class="headerlink" title="1.2.1. 注意"></a>1.2.1. 注意</h3><p> &ensp;  &ensp; cookie只是实现session的其中一种方案。虽然是最常用的，但并不是唯一的方法。禁用cookie后还有其他方法存储，比如放在url中<br>现在大多都是Session + Cookie，但是只用session不用cookie，或是只用cookie，不用session在理论上都可以保持会话状态。可是实际中因为多种原因，一般不会单独使用<br>用session只需要在客户端保存一个id，实际上大量数据都是保存在服务端。如果全部用cookie，数据量大的时候客户端是没有那么多空间的。<br>如果只用cookie不用session，那么账户信息全部保存在客户端，一旦被劫持，全部信息都会泄露。并且客户端数据量变大，网络传输的数据量也会变大</p>
<h3 id="1-2-2-cookie和session通俗小结"><a href="#1-2-2-cookie和session通俗小结" class="headerlink" title="1.2.2. cookie和session通俗小结"></a>1.2.2. cookie和session通俗小结</h3><p>简而言之, session 有如用户信息档案表, 里面包含了用户的认证信息和登录状态等信息. 而 cookie 就是用户通行证</p>
<h2 id="1-3-token定义"><a href="#1-3-token定义" class="headerlink" title="1.3. token定义"></a>1.3. token定义</h2><p>token 也称作令牌，由uid+time+sign[+固定参数]<br>token 的认证方式类似于临时的证书签名, 并且是一种服务端无状态的认证方式, 非常适合于 REST API 的场景. 所谓无状态就是服务端并不会保存身份认证相关的数据。</p>
<h3 id="1-3-1-token组成"><a href="#1-3-1-token组成" class="headerlink" title="1.3.1. token组成"></a>1.3.1. token组成</h3><p>uid: 用户唯一身份标识<br>time: 当前时间的时间戳<br>sign: 签名, 使用 hash/encrypt 压缩成定长的十六进制字符串，以防止第三方恶意拼接<br>固定参数(可选): 将一些常用的固定参数加入到 token 中是为了避免重复查库</p>
<h3 id="1-3-2-存放"><a href="#1-3-2-存放" class="headerlink" title="1.3.2. 存放"></a>1.3.2. 存放</h3><p>token在客户端一般存放于localStorage，cookie，或sessionStorage中。在服务器一般存于数据库中</p>
<h3 id="1-3-3-token认证流程"><a href="#1-3-3-token认证流程" class="headerlink" title="1.3.3. token认证流程"></a>1.3.3. token认证流程</h3><p>token 的认证流程与cookie很相似</p>
<ul>
<li>用户登录，成功后服务器返回Token给客户端。</li>
<li>客户端收到数据后保存在客户端</li>
<li>客户端再次访问服务器，将token放入headers中</li>
<li>服务器端采用filter过滤器校验。校验成功则返回请求数据，校验失败则返回错误码</li>
</ul>
<h3 id="1-3-4-token可以抵抗csrf，cookie-session不行"><a href="#1-3-4-token可以抵抗csrf，cookie-session不行" class="headerlink" title="1.3.4. token可以抵抗csrf，cookie+session不行"></a>1.3.4. token可以抵抗csrf，cookie+session不行</h3><p>&nbsp;&nbsp;因为form 发起的 POST 请求并不受到浏览器同源策略的限制，因此可以任意地使用其他域的 Cookie 向其他域发送 POST 请求，形成 CSRF 攻击。</br><br>在post请求的瞬间，cookie会被浏览器自动添加到请求头中。</br>但token不同，token是开发者为了防范csrf而特别设计的令牌，浏览器不会自动添加到headers里，攻击者也无法访问用户的token，所以提交的表单无法通过服务器过滤，也就无法形成攻击。</p>
<h2 id="1-4-分布式情况下的session和token"><a href="#1-4-分布式情况下的session和token" class="headerlink" title="1.4. 分布式情况下的session和token"></a>1.4. 分布式情况下的session和token</h2><p>我们已经知道session时有状态的，一般存于服务器内存或硬盘中，当服务器采用分布式或集群时，session就会面对负载均衡问题。</p>
<p>负载均衡多服务器的情况，不好确认当前用户是否登录，因为多服务器不共享session。这个问题也可以将session存在一个服务器中来解决，但是就不能完全达到负载均衡的效果。当今的几种解决session负载均衡的方法。<br>而token是无状态的，token字符串里就保存了所有的用户信息</p>
<p>客户端登陆传递信息给服务端，服务端收到后把用户信息加密（token）传给客户端，客户端将token存放于localStroage等容器中。客户端每次访问都传递token，服务端解密token，就知道这个用户是谁了。通过cpu加解密，服务端就不需要存储session占用存储空间，就很好的解决负载均衡多服务器的问题了。这个方法叫做JWT(Json Web Token)</p>
<h2 id="1-5-总结"><a href="#1-5-总结" class="headerlink" title="1.5. 总结"></a>1.5. 总结</h2><p>session存储于服务器，可以理解为一个状态列表，拥有一个唯一识别符号sessionId，通常存放于cookie中。服务器收到cookie后解析出sessionId，再去session列表中查找，才能找到相应session。依赖cookie<br>cookie类似一个令牌，装有sessionId，存储在客户端，浏览器通常会自动添加。<br>token也类似一个令牌，无状态，用户信息都被加密到token中，服务器收到token后解密就可知道是哪个用户。需要开发者手动添加。<br>jwt只是一个跨域认证的方案<br><strong>补充:JWT</strong></p>
<p>JWT就是token的一种实现方式，并且基本是java web领域的事实标准。</p>
<p>JWT全称是JSON Web Token。基本可以看出是使用JSON格式传输token</p>
<p>JWT 由 3 部分构成:</p>
<p>Header :描述 JWT 的元数据。定义了生成签名的算法以及 Token 的类型。Payload（负载）:用来存放实际需要传递的数据Signature（签名）：服务器通过Payload、Header和一个密钥(secret)使用 Header 里面指定的签名算法（默认是 HMAC SHA256）生成。流程：</p>
<p>在基于 Token 进行身份验证的的应用程序中，用户登录时，服务器通过Payload、Header和一个密钥(secret)创建令牌（Token）并将 Token 发送给客户端，</p>
<p>然后客户端将 Token 保存在 Cookie 或者 localStorage 里面，以后客户端发出的所有请求都会携带这个令牌。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP Header 的 Authorization字段中：Authorization: 你的Token。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/1.%20%E6%88%91%E7%9A%84%E6%96%87%E4%BB%B6/session%EF%BC%8Ccookie%E5%92%8Ctoken%E7%9A%84%E5%8C%BA%E5%88%AB.html" data-id="ckw6cu3ph000blsdceifz6lyv" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/11/18/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>